#############################
path = "_GITHUB REPO _TOFFEE_"
#############################
library(roxygen2)
roxygen2::roxygenize(path)
try_seed <- function(expr, maxrun = 100) {
expr <- substitute(expr)
for (i in 1:maxrun) {
seed <- round(runif(1, 1000, 9999))
set.seed(seed)
eval(expr, envir = parent.frame())
readline(sprintf("seed = %s, Press space to continue!", seed))
}
}
})
try_seed({
hist(rnorm(100))
})
#' Try different seeds for a particular chunk of code
#' @description (Re)runs a chunk of code any time you press enter, every time providing the seed used. Useful if the code includes random number generation
#' @param expr
#' @param maxrun The maximum number of times it reruns the code
#'
#' @return
#' @export
#'
#' @examples
try_seed <- function(expr, maxrun = 100) {
expr <- substitute(expr)
for (i in 1:maxrun) {
seed <- round(runif(1, 0, 99999))
set.seed(seed)
eval(expr, envir = parent.frame())
readline(sprintf("seed = %s, Press enter to continue!", seed))
}
}
try_seed({
hist(rnorm(100))
})
try_seed({
a = rnorm(1,0,1)
a
})
try_seed(maxrun=2,{
a = rnorm(1,0,1)
a
})
try_seed({
a = rnorm(1,0,1)
print(a)
})
try_seed({
a = rnorm(1,0,1)
print(a)
})
try_seed(expr={
a = rnorm(1,0,1)
print(a)
})
z2SumScore = function(z=z,items=10,levels=1:4){
require(scales)
itemDiff = seq(-2,2,length.out=items)
resp = matrix(rep(z,length(items)),nrow=length(z),ncol=items)
resp = t(t(resp) + itemDiff)
resp = matrix(resp, nrow=length(z),ncol=items)
resp = pnorm(resp)*(max(levels)-min(levels))+min(levels)
resp = round(rowSums(resp))
return(resp)
}
y = rnorm(100)
z2SumScore(y)
z2SumScore = function(z=NA,nItems=10,levels=1:4,itemZmin=-2,itemZmax=+2){
require(scales)
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
resp = matrix(rep(z,length(items)),nrow=length(z),ncol=items)
resp = t(t(resp) + itemDiff)
resp = matrix(resp, nrow=length(z),ncol=items)
resp = pnorm(resp)*(max(levels)-min(levels))+min(levels)
resp = round(rowSums(resp))
return(resp)
}
z2SumScore(y)
z2SumScore = function(z=NA,nItems=10,levels=1:4,itemZmin=-2,itemZmax=+2){
require(scales)
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
resp = matrix(rep(z,length(nItems)),nrow=length(z),ncol=nItems)
resp = t(t(resp) + itemDiff)
resp = matrix(resp, nrow=length(z),ncol=nItems)
resp = pnorm(resp)*(max(levels)-min(levels))+min(levels)
resp = round(rowSums(resp))
return(resp)
}
z2SumScore(y)
z2SumScore = function(z=NA,nItems=10,minResp=1,maxResp=4,itemZmin=-2,itemZmax=+2){
require(scales)
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
resp = matrix(rep(z,length(nItems)),nrow=length(z),ncol=nItems)
resp = t(t(resp) + itemDiff)
resp = matrix(resp, nrow=length(z),ncol=nItems)
resp = pnorm(resp)*(max(levels)-min(levels))+min(levels)
resp = round(rowSums(resp))
return(resp)
}
5.5 %%2
6 %%2
?stop
z2SumScore = function(z=NA,nItems=10,minResp=1,maxResp=4,itemZmin=-2,itemZmax=+2){
require(scales)
if(minResp %% 2 !=0 | maxResp %% 2 !=0) stop("minResp and maxResp must be integer numbers")
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
resp = matrix(rep(z,length(nItems)),nrow=length(z),ncol=nItems)
resp = t(t(resp) + itemDiff)
resp = matrix(resp, nrow=length(z),ncol=nItems)
resp = pnorm(resp)*(max(levels)-min(levels))+min(levels)
resp = round(rowSums(resp))
return(resp)
}
z2SumScore(y)
1.5%%1
5%%1
0.9%%1
z2SumScore = function(z=NA,nItems=10,minResp=1,maxResp=4,itemZmin=-2,itemZmax=+2){
require(scales)
if(minResp %% 1 !=0 | maxResp %% 1 !=0) stop("minResp and maxResp must be integer numbers")
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
resp = matrix(rep(z,length(nItems)),nrow=length(z),ncol=nItems)
resp = t(t(resp) + itemDiff)
resp = matrix(resp, nrow=length(z),ncol=nItems)
resp = pnorm(resp)*(max(levels)-min(levels))+min(levels)
resp = round(rowSums(resp))
return(resp)
}
z2SumScore(y)
y
minResp=1
maxResp=4
minResp %% 1 !=0 | maxResp %% 1 !=0
itemZmin=-2
itemZmax=+2
z2SumScore = function(z=NA,nItems=10,minResp=1,maxResp=4,itemZmin=-2,itemZmax=+2){
require(scales)
levels = min(c(minResp,maxResp)):max(c(minResp,maxResp))
if(minResp %% 1 !=0 | maxResp %% 1 !=0) stop("minResp and maxResp must be integer numbers")
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
resp = matrix(rep(z,length(nItems)),nrow=length(z),ncol=nItems)
resp = t(t(resp) + itemDiff)
resp = matrix(resp, nrow=length(z),ncol=nItems)
resp = pnorm(resp)*(max(levels)-min(levels))+min(levels)
resp = round(rowSums(resp))
return(resp)
}
z2SumScore(y)
z2SumScore(y,minResp=0)
z2SumScore(y,minResp=0,maxResp=10)
z2SumScore(y,minResp=0,maxResp=10.1)
z2SumScore = function(z=NA,nItems=10,minResp=1,maxResp=4,itemZmin=-2,itemZmax=+2){
require(scales)
levels = min(c(minResp,maxResp)):max(c(minResp,maxResp))
if(minResp %% 1 !=0 | maxResp %% 1 !=0) stop("both minResp and maxResp must be integer numbers")
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
resp = matrix(rep(z,length(nItems)),nrow=length(z),ncol=nItems)
resp = t(t(resp) + itemDiff)
resp = matrix(resp, nrow=length(z),ncol=nItems)
resp = pnorm(resp)*(max(levels)-min(levels))+min(levels)
resp = round(rowSums(resp))
return(resp)
}
z2SumScore(y,minResp=0,maxResp=10.1)
z2SumScore(y,minResp=0,maxResp=10)
hist(z2SumScore(y))
hist(z2SumScore(y),itemZmin=0)
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
nItems=10
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
itemDiff
nItems=10
require(scales)
levels = min(c(minResp,maxResp)):max(c(minResp,maxResp))
if(minResp %% 1 !=0 | maxResp %% 1 !=0) stop("both minResp and maxResp must be integer numbers")
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
resp = matrix(rep(z,length(nItems)),nrow=length(z),ncol=nItems)
resp = t(t(resp) + itemDiff)
z=y
require(scales)
levels = min(c(minResp,maxResp)):max(c(minResp,maxResp))
if(minResp %% 1 !=0 | maxResp %% 1 !=0) stop("both minResp and maxResp must be integer numbers")
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
resp = matrix(rep(z,length(nItems)),nrow=length(z),ncol=nItems)
resp = t(t(resp) + itemDiff)
resp = matrix(resp, nrow=length(z),ncol=nItems)
resp = pnorm(resp)*(max(levels)-min(levels))+min(levels)
resp = round(rowSums(resp))
resp
hist(z2SumScore(y),itemZmin=0)
hist(z2SumScore(y,itemZmin=0))
hist(z2SumScore(y,itemZmin=0))
hist(z2SumScore(y,itemZmin=0))
hist(z2SumScore(y,itemZmin=0))
hist(z2SumScore(y,itemZmin=0))
hist(z2SumScore(y,itemZmin=0))
hist(z2SumScore(y,itemZmin=0))
hist(z2SumScore(y,itemZmin=0))
hist(z2SumScore(y),itemZmin=0)
hist(z2SumScore(y,itemZmin=0))
hist(z2SumScore(y,itemZmin=0))
hist(z2SumScore(y,itemZmin=0))
hist(z2SumScore(y,itemZmin=0))
hist(z2SumScore(y,itemZmin=1))
hist(z2SumScore(y,itemZmin=4))
hist(z2SumScore(y,itemZmax=0))
hist(z2SumScore(y,itemZmax=-5))
hist(z2SumScore(rnorm(100)-3,itemZmax=-5))
rnorm(100)-3
hist(z2SumScore(rnorm(100)-3,itemZmin=-5,itemZmax=0))
hist(z2SumScore(rnorm(100)-3,itemZmin=5,itemZmax=0))
z2SumScore = function(z=NA,nItems=10,minResp=1,maxResp=4,itemZmin=-2,itemZmax=+2){
require(scales)
levels = min(c(minResp,maxResp)):max(c(minResp,maxResp))
if(minResp %% 1 !=0 | maxResp %% 1 !=0) stop("both minResp and maxResp must be integer numbers")
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
resp = matrix(rep(z,length(nItems)),nrow=length(z),ncol=nItems)
resp = t(t(resp) - itemDiff)
resp = matrix(resp, nrow=length(z),ncol=nItems)
resp = pnorm(resp)*(max(levels)-min(levels))+min(levels)
resp = round(rowSums(resp))
return(resp)
}
hist(z2SumScore(rnorm(100)-3,itemZmin=5,itemZmax=0))
hist(z2SumScore(rnorm(100)-3,itemZmin=-5,itemZmax=-1))
hist(z2SumScore(rnorm(100)-3,itemZmin=-1,itemZmax=-5))
hist(z2SumScore(rnorm(100)-3,itemZmin=-1,itemZmax=-5))
hist(z2SumScore(rnorm(100)-3,itemZmin=-1,itemZmax=-5))
hist(z2SumScore(rnorm(100)-3,itemZmin=-1,itemZmax=-5))
hist(z2SumScore(rnorm(100)-3,itemZmin=-1,itemZmax=-5))
-2 %% 1
-2.2 %% 1
#' @description Transform z-score(s) into "plausible" Sum Score(s) that could be obtained from a test or questionnaire with a finite number of items with binomial or ordinal responses
#' @param z A single z-score or a vector of z-scores, plausibly reflecting the "true" latent scores. Must be numeric
#' @param nItems The number of items composing the test or questionnaire
#' @param minResp The minimum observable response to a single item (for binomial responses 0 is recommended; for a Likert scale in 1-4, should be 1). Must be an integer number
#' @param maxResp The maximum observable response to a single item (for binomial responses 1 is recommended; for a Likert scale in 1-4, should be 4). Must be an integer number
#' @param itemZmin The item difficulty of the easiest item, on a z-score scale. Other item difficulties will be computed on equal interval between intemZmin and itemZmax
#' @param itemZmax The item difficulty of the most difficult item, on a z-score scale
#'
#' @return The "z" vector transformed in a vector of plausible sum scores
#' @export
z2SumScore = function(z=NA,nItems=10,minResp=1,maxResp=4,itemZmin=-2,itemZmax=+2){
require(scales)
levels = min(c(minResp,maxResp)):max(c(minResp,maxResp))
if(minResp %% 1 !=0 | maxResp %% 1 !=0) stop("both minResp and maxResp must be integer numbers")
itemDiff = seq(itemZmin,itemZmax,length.out=nItems)
resp = matrix(rep(z,length(nItems)),nrow=length(z),ncol=nItems)
resp = t(t(resp) - itemDiff)
resp = matrix(resp, nrow=length(z),ncol=nItems)
resp = pnorm(resp)*(max(levels)-min(levels))+min(levels)
resp = round(rowSums(resp))
return(resp)
}
?z2SumScore
